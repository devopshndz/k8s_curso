### Variables, config map y secrets
Las varaibles son objetos basicos que podemos inyectar al contenedor para poder modificar su comportamiento, ponerle propiedades, pasarle parametros.
configmap es el conjunto de valores que podemos colocar en el contenedor para cambiarle el comportamiento del contenedor.
El secret es igual que un configmap pero con informacion protegida.

### variables
usaremos el archivo var1.yaml
la seccion env del fichero, definimos una lista de clave valor con las variables
env:
    - name: NOMBRE
      value: "CURSO DE KUBERNETES"
    - name: PROPIETARIO
      value: "Apasoft Training"

hacemos apply al archivo y podemos ver el pod que se crea con get pods. Luego podemos hacer un exec al pod con su nombre y pasar el comando printenv para imprimir las variables incluyendo las
que colocamos.
Asi inyectamos variables en los contenedores y ya podemos utilizar dichas variables
$ echo $NOMBRE
$ echo $PROPIETARIO

### ejemplo con mysql
vamos a usar mysql.yaml
para estos ejemplos siempre es bueno guiarse de la documentacion de la imagen a utilizar proveniente de dockerhub
apply
le tuve que cambiar la imagen de la db a la 8.1 debido a que la 5.7 no estaba arrancando 

### configmaps
Cuando las variables que pasamos son muy grandes, es mejor tener un fichero que pueda almacenar todas las varaibles y sea mejor a la hora de aprovecharlo, eso hace el configmap
Ficheros que incorporan claves valor de una forma muy sencilla

### forma imperativa
$ kubectl create configmap cf1 --from-literal=usuario=usu1 --from-literal=password=pass1
con el comando anterior creamos un configmap (cm) de nombre cf1 y le estamos pasando 2 variables con el --from-literal, usuario y password
$ kubectl get cm --> ver los configmap existentes
$ kubectl describe cm cf1 --> describe el cm cf1
$ kubectl get cm cf1 -o yaml --> obtener la info del cf1 en formato yaml

### crear configmap desde fichera, forma declarativa
vamos a trabajar con el fichero datos_mysql.properties, pod1.yaml y game.properties dentro del directorio configmap_fichero
$ kubectl create configmap datos-mysql --from-file=datos_mysql.properties --> creamos un configmap importandole los datos (--from-file) del archivo datos_mysql.properties
al crear este configmap pasan cosas: primero cuando le damos un get cm, nos muestra que carga 1 solo valor y no 4, esto es porque al pasarle --from-file se crea un configmap
pero detectando que lo que estÃ¡ dentro del archivo, es un solo valor. 

vamos a usar el fichero pod1.yaml y vamos a trabajar con el configmap creado
apply el pod
y entramos al pod
$ kubectl exec -it pod1 -- bash
y luego un printenv nos mostrara las variables, pero si hacemos un echo $DATOS_MYSQL nos muestra lo siguiente
$DATOS_MYSQL
 MYSQL_DATABASE=kubernetesetes 
nos muestra solo el primer dato. esto no vale para cargar variables de entorno

para corregir esto de que tome todas las variables y las almacene como variables indepenientes:
$ kubectl create configmap datos-mysql2 --from-env-file datos_mysql.properties --> con el --from-env-file si toma todas las variables de entorno como tal y no las engloba como 1 sola.
ahora si le damos:
$ kubectl get cm
datos-mysql2       4      18s
nos muestra 4 datos.
y lo vemos mejor:
$ kubectl get cm datos-mysql2 -o yaml
apiVersion: v1
data: # aqui estan las variables de entorno
  MYSQL_DATABASE: kubernetes
  MYSQL_PASSWORD: usupass
  MYSQL_ROOT_PASSWORD: kubernetes
  MYSQL_USER: usudb
kind: ConfigMap
metadata:
  creationTimestamp: "2023-09-18T15:59:14Z"
  name: datos-mysql2
  namespace: default
  resourceVersion: "117566"
  uid: c06920cf-8b04-46ff-8835-7cfd16ef7df8

$ kubectl describe cm datos-mysql2 
Name:         datos-mysql2
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
MYSQL_PASSWORD:
----
usupass
MYSQL_ROOT_PASSWORD:
----
kubernetes
MYSQL_USER:
----
usudb
MYSQL_DATABASE:
----

variamos el pod1 para colocar el archivo nuevo. debemos colocar en vez del configmap anterio datos-mysql, colocar el nuevo, datos-mysql2, y pasarlo todo como variable de entorno envFrom
desde un configMapRef para referenciar al que hemos creado, asi toma los datos como si fueran variables de entorno
envFrom: # cargar el entorno desde un fichero de configmap
      - configMapRef:
          name: datos-mysql2

al final entramos al pod y con un printenv:
root@pod1:/# printenv
_=/usr/bin/printenv
KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443
MYSQL_ROOT_PASSWORD=kubernetes
KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1
MYSQL_USER=usudb
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP_PROTO=tcp
HOME=/root
SHLVL=1
PWD=/
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NPM_CONFIG_LOGLEVEL=info
MYSQL_PASSWORD=usupass
KUBERNETES_SERVICE_HOST=10.96.0.1
KUBERNETES_SERVICE_PORT=443
MYSQL_DATABASE=kubernetes
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT=tcp://10.96.0.1:443
TERM=xterm
HOSTNAME=pod1
NODE_VERSION=4.4.2

podemos listar de manera individual ya que no reconoce la variable DATOS_MYSQL
$ echo $MYSQL_USER
usudb


### ultimo ejemplo configmap con mysql sin el create
vamos a trabajar con datos_mysql.properties, datos-mysql-env.yaml y mysql.yaml
configmap mediante yaml:

apiVersion: v1
data:
  MYSQL_DATABASE: kubernetes
  MYSQL_PASSWORD: usupass
  MYSQL_ROOT_PASSWORD: kubernetes
  MYSQL_USER: usudb
kind: ConfigMap
metadata:
  name: datos-mysql-env
  namespace: default

creamos el configmap mediante apply
$ kubectl apply -f datos-mysql-env.yaml
$ kubectl get cm
datos-mysql-env    4      13s

una vez creado, vamos a cargarlo en el fichero mysql.yaml
esto sera dado mediante la referencia de la variable y el cm, dentro de mysql.yaml:
env:
    - name: MYSQL_ROOT_PASSWORD
        valueFrom:
        configMapKeyRef:
            name: datos-mysql-env # de donde lo buscamos
            key: MYSQL_ROOT_PASSWORD # que variable buscamos

$ kubectl apply -f mysql.yaml --> creamos el deployment de mysql
y listo, podemos entrar al pod y ver que las variables estan chidas.
nos conectamos a la db:
desde el pod (dentro del pod)
$ mysql -u usudb -p kubernetes --> le pasamos usuario, el -p no le colocamos la password, pero si le pasamos la db que se llama kubernetes, cuando nos pida el password se lo colocamos
y ya entramos a la db:

$ mysql -u usudb -p kubernetes
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 8.1.0 MySQL Community Server - GPL

Copyright (c) 2000, 2023, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| kubernetes         |
| performance_schema |
+--------------------+
3 rows in set (0.01 sec)

### configmap y volumenes
hay una caracteristica muy importante y util de configmap y es que podemos dejarlos en un determinado sitio de nuestro container como si fueran un fichero.
Cogemos esa info que dejamos en algun sitio y posteriormente utilizarla para cualquier cosa dentro del contenedor.
Recordemos que ni las variables, configmap y secrets son utiles, solo cuando los usamos dentro del contendor. vamos a dejar esa info dentro de un volumen

vamos a trabajar con pod1.yaml y configmap.yaml.
aplicamos ambos, primero el configmap.yaml y luego el pod1.
$ kubectl apply -f . --> aplicamos todos los archivo .yaml que estan dentro del directorio.
$ kubectl describ cm config-volumen
Data
====
ENTORNO:
----
desarrollo
VERSION:

obtenemos el pod que es pod1 y entramos en el, por medio de sh ya que la imagen es una shell de linux y no tiene bash
$ kubectl exec -it pod1 -- sh  
vemos los volumenes
$ cd /etc/config-map # cat ENTORNO
desarrollo
$ /etc/config-map # ls -l
total 0
lrwxrwxrwx    1 root     root            14 Sep 18 16:52 ENTORNO -> ..data/ENTORNO
lrwxrwxrwx    1 root     root            14 Sep 18 16:52 VERSION -> ..data/VERSION

nos muestra los volumens montados